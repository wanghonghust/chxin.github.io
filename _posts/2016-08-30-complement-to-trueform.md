---
layout: post
title: 由补码求原码的三种方法
author: CHxin
date: 2016-8-30
categories: blog
tags: [Basic,Artifice]
description: 二进制中，负数的补码，很难一眼看穿是几。这里列举三种方法求得原码：定义、二次补码、-128运算。
---

&emsp;&emsp;在二进制运算中，减法运算通常会转变为加法运算，其中至关重要的一步就是求得负数的补码。这使得负数的补码比源码出现的频率更多，也更加重要了。  

&emsp;&emsp;机器可以直接利用补码进行运算，它应该很是喜欢这个人为它创造的编码，但是，可真苦了我们这些习惯减法和十进制负数的人了，因为无法一眼看穿这串以一开头的数字到底对应的是那个负数。为此，需要进行一系列简单的转换才能识得“庐山真面目”。  

&emsp;&emsp;为了进一步加深对补码的理解，也是为了消除对补码的恐惧感并加快运算速度，这里总结下常用的三种方法，并列举我的一些经验。  

> &emsp;&emsp;1.由求补码的定义，反推，得到原码；  

> 补码是取反加一，则求原码就是减一取反。当然取反加一也是可以，就是下一种方法。  

>> 举例：[（-43）D]补码=（0010 1011）取反+1=1101 0100 +1=1101 0101 。看到1101   0101，首先感觉一定很歪腻吧。首先看到是1开头，知道这是负数（一般负数不会以原码形式出现），然后默念减一取反，就是1101 0100取反，是0010 1011，是43，再加上符号。   

### **正数补码和原码相同**  

> &emsp;&emsp;2.二次补码得到原码的数值部分；  

> 这句话有点绕，就用表达式来说明下：[[-A]补]补=A。原因很简单，A（正数）在数轴的位置，是在原点右侧A个单位，按位取反后，得到的就是位于数轴左侧为负，多少个单位呢，然后加一，是右移一个单位，再取反，到了数轴右侧为正，多少个单位呢，然后再加一，是不是与A重合了。  
> 这种方法不见得比第一种方法简单，只是一种补充，这个说明的过程，是对二进制的各种编码的一种理解。关于上面提到的“多少个单位”，想必已经知道了吧，例如0000 0011取反后是1111 1100，加起来是1 0000 0000，也就是8位满格,128。所以取反，就是把我离终点(128)的距离，变成了你离原点的距离。  

> &emsp;&emsp;3.与最大负数-128的补码进行比较，得到原码；  
（-128）D的补码是1000 0000，数值部分为最小。所以对于负数X，有：(X)D - (-128)D = (X)B - (1000 0000)B = (X)B的数值部分。因此，（X）D=（-128）+ (X)B的数值部分。    
>> 举例说明吧，[（-43）D]补码=1101 0101 ，原码就是-128+（101 0101）=-128+85=-43.  

&emsp;&emsp;不知道现在能否一眼看出反码对应的负数了吗，反正我是可以了。我是这样进行的(只是数值部分)：  
> （1111 1111）B=（FF）H，所以是0*16+1*1=1；  
> （1111 1001）B=（F9）H，所以是0*16+7*1=7；  
> （1111 0000）B=（F0）H，所以是0*16+1*16=16；  
> （1110 1010）B=（EA）H，所以是1*16+1*6=22；  
> （1101 1010）B=（DA）H，所以是2*16+1*6=38  

### 第一次尝试写课程总结，尝试把思路具体到每个细节，还是很有意思的。只是好多地方想要表达清楚还真有点费劲啊。
